ReentrantLook 实现了Lock接口，并提供了与synchronized相同的互斥性与可见性和内存可见性
在获取ReentrantLock代码块时，有着与进入同步代码块相同的内存意义，在释放ReentrantLock时
有着与退出同步代码块相同的内存语义。

关于Lock接口：
public interface Lock{
   void lock();
   void lockInterruptibly() throws InterruptedException;
   boolean tryLook();
   boolean tryLock(long timeout,Time unit) throws InterruptedException;
   void unlock();
   Condition newCondition();
}

如果没有使用Finally来释放Lock那么相当于启动了一个定时炸弹，当定时炸弹爆炸时，将很难追踪
到当初发生错误的位置，因为没有记住应该释放锁的时间和位置，这就是ReentrantLock不能完全替代
synchronized的原因：它更加危险，因为当程序的执行离开被保护的代码块时，不能自动清除锁。虽然在
finally快中释放代码并不难，但是也可能忘记。
