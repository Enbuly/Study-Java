BinomialQueue£º
public class BinomialQueue()
{
    private static class Node<AnyType>
    {
        AnyType element;
        Node<AnyType> leftChild;
        Node<AnyType> nextSibling;

        Node(AnyType theElement)
        {this(theElement,null,null);}
        Node(AnyType theElement,Node<AnyType>lt,
        Node<AnyType> nt)
        {
            element=theElement;
            leftChild=lt;
            nextSibling=nt;
        }
    }

    private static final int DEFAULT_TREES=1;
    private int currentSize;
    private Node<AnyType> [] theTrees;

    public BinomialQueue()
    {/*See online code*/}

    public BinomialQueue(AnuType item)
    {/*See online code*/}

    public Node<AnyType> combineTrees(Node<AnyType> t1,
    Node<AnyType> t2)
    {
        if(t1.element>t2.element)
             return combineTrees(t2,t1);
        t2.nextSibling=t1.leftChild;
        t1.leftChild=t2;
        return t1;
    }

    public void merge(BinomialQueue<AnyType> rhs)
    {
         if(this==rhs)
             return;
         currentSize=currentSize+rhs.length;
         if(currentSize>capacity())
         {
             int maxLength=Math.max(theTrees.length,
             rhs.theTrees.length);
             expandTheTrees(maxLength+1);
         }
         Node<AnyType> carry=null;
         for(int i=0,j=1;j<=currentSize;i++,j=j*2)
         {
              Node<AnyType> t1=theTrees[i];
              Node<AnyType> t2=i<rhs.theTrees.length?
              rhs.theTrees[i]:null;
              int whichCase=t1==null?0:1;
              whichCase+=t2==null?0:2;
              whichCase+=t3==null?0:4;
              switch(whichCase)
              {
                  case 0:/*do nothing*/
                  case 1:/*do nothing*/
                     break;
                  case 2:
                     theTrees[i]=t2;
                     rhs.theTrees[i]=null;
                     break;
                  case 3:
                     carry=combineTrees(t1,t2);
                     theTrees[i]=rhs.theTrees[i]=null;
                  case 4:
                     theTrees[i]=carry;
                     carry=null;
                     break;
                  case 5:
                     carry=conbineTrees(t1,carry);
                     theTrees[i]=null;
                     break;
                  case 6:
                     carry=conbineTrees(t2,carry);
                     theTrees[i]=null;
                     break;
                  case 7:
                     theTrees[i]=carry;
                     carry=combineTrees(t1,t2);
                     rhs.theTrees[i]=null;
                     break;
              }
          }
          for(int k=0;k<rhs.theTrees.length;k++)
              rhs.theTrees[k]=null;
          rhs.currentSize=0;
    }

    public void insert(AnyType x)
    {merge(new BinomialQueue<AnyType>(x));}

    public AnyType deleteMin()
    {/*See online code*/}

    public AnyType deleteMin()
    {
         if(isEmpty())
             throw new UnderException();
         int minIndex=findMinIndex();
         AnyType minItem=theTrees[minIndex].element;
         Node<AnyType> deletedTree=
         theTree[minIndex].leftChild;
         BinomialQueue<AnyType> deletedQueue
         =new BinomialQueue<AnyType>();
         deletedQueue.expandTheTrees(minIndex+1);
         deletedQueue.currentSize=(1<<minIndex)-1;
         for(int j=minIndex-1;j>=0;j--)
         {
             deletedQueue.theTrees[j]=deletedTree;
             deletedTree=deletedTree.nextSibling;
             deleteQueue.theTree[j].nextSibling=null;
         }
         theTrees[minIndex]=null;
         currentSize=currentSize-deletedQueue.currentSize+1;
         meger(deleteQueue);
         return minItem;
    }

    public boolean isEmpty()
    {return currentSize==0;}

    public void makeEmpty()
    {/*See online code*/}

    public void expandTheTrees(int newNumTrees)
    {/*See online code*/}

    public int capacity()
    {return(1<<theTrees.length)-1;}

    private int findMinIndex()
    {/*See online code*/}

}