分离链接法：
public class SeparateChainingHashTable<AnyType>{
    private static final int DEFAULT_TABLE_SIZE=101;
    private List<AnyType> []theLists;
    private int currentSize;

    public SeparateChainingHashTable()
    {this(DEFAULT_TABLE_SIZE);}

    public SeparateChainingHashTable(int size){
         theLists=new LinkedList[nextPrime(size)];
         for(int i=0;i<theLists.length;i++)
             theLists[i]=new LinkedList<AnyType>();
    }

    public void makeEmpty(){
       for(int i=0;i<theLists.length;i++)
           theList[i].clear();
       current=0;
    }

    public boolean contains(AnyType x){
        List<AnyType> whichList=theLists[myhash(x)];
        return whichList.contains(x);
    }

    public void insert(AnyType x){
        List<AnyType> whichList=theLists[myhash(x)];
        if(!whichList.contains(x)){
             whichList.add(x);
             if(++currentSize>theLists.length)
                 rehash();
        }
    }

    public void remove(AnyType x){
        List<AnyType> whichList=theLists[myhash(x)];
        if(whichList.contains(x)){
             whichList.remove(x);
             currentSize--;
        }
    }

    public void rehash(){
         List<AnyType> [] oldLists=theLists;
         theList=new List[nextPrime(2*theList.length)];
         for(int j=0;i<theList.length;j++)
              theList[i]=new LinkedList<AnyType>();
         currentSize=0;
         for(int i=0;i<oldLists.length;i++)
             for(AnyType item:oldLists[i])
                 insert(item);
                 //这里调用的自己写的类的insert方法，而不是对oldList对象进行add
    }
}


public int myhash(AnyType x){
    int hashVal=x.hashCode();
    hashVal=hashVal%theLists.length;
    if(hashVal<0)
        hashVal=hashVal+theLists.length;
    return hashVal;
}
---------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------
线性探测发：
  After89   After18   After49   After58   After69
0                      49        49       49
1                                58       58
2                                         69
3
4
5
6
7
8            18        18        18       18
9    89      89        89        89       89

平方探测发：
  After89   After18   After49   After58   After69
0                     49        49       49
1
2                               58       58
3                                        69
4
5
6
7
8           18        18        18       18
9    89     89        89        89       89

public class QuadraticProbingHashTable<AnyType>{
    private static final int DEFAULT_TABLE_SIZE=11;
    private HashEntry<AnyType> [] array;
    private int currentSize;

    public static class HashEntry<AnyType>{
        public AnyType element;
        public boolean isActive;
        public HashEntry(AnyType e)
        {this(e,true);}
        public HashEntry(AnyType e,boolean i)
        {element=e;isActive=i;}
    }

    public QuadraticProbingHashTable()
    {this(DEFAULT_TABLE_SIZE);}

    public QuadraticProbingHashTable(int size)
    {allocateArray(size);makeEmpty();}

    public void allocateArray(int arraysize)
    {array=new HashEntry(arraysize);}

    public void makeEmpty(){
        currentSize=0;
        for(int i=0;i<array.length;i++)
            array[i]=null;
    }

    public boolean contains(AnyType x){
        int currentPos=findPos(x);
        return isActive(currentPos);
    }

    public int findPos(AnyType x){
         int offset=1;
         int currentPos=myhash(x);
         //使用平方探测法进行散列
         while(array[currentPos]!=null&&
         !array[currentPos].element.equal(x)){
             currentPos=currentPos+offset;
             offset=offset+2;
             if(currentPos>array.length)
                 currentPos=currentPos-array.length;
         }
         return currentPos;
    }

    public boolean isActive(int currentPos){
        return array[currentPos]!=null&&
        array[currentPos].isActive;
    }

    public void insert(AnyType x){
        int currentPos=findPos(x);
        if(isActive(currentPos))
            return;
        array[currentPos]=new HashEntry<AnyType>(x,true);
        if(++currentSize>array.length/2)
            rehash();
    }

    private void rehash(){
         HashEntry<AnyType> []oldArray=array;
         allocateArray(nextPrime(2*oldArray.length))
         currentSize=0;
         for(int i=0;i<oldArray.length;i++)
             if(oldArray[i]!=null&&oldArray[i].isActive)
                  insert(oldArray[i].element);
    }

    public void remove(AnyType x){
        int currentPos=findPos(x);
        if(isActive(currentPos))
            array[currentPos].isActive=false;
    }

}